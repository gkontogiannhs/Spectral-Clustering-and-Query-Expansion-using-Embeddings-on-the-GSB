from numpy import array
from math import log2
from json import load
from os.path import join, exists
from os import makedirs, getcwd
from pickle import dump, load
from bz2 import BZ2File
from pandas import DataFrame
from infre.tools import apriori
from infre.metrics import precision_recall

from infre.models import BaseIRModel


class SetBased(BaseIRModel):
    def __init__(self, collection=None):
        
        # inherit from base model
        super().__init__(collection)

        # model name
        self.model = self._model()


    def _model(self): return __class__.__name__
    

    def fit(self, queries, mf=1):

        # inverted index of collection documents
        inv_index = self.collection.inverted_index

        # for each query
       
        for i, query in enumerate(queries, start=1):

            # apply apriori to find frequent termsets
            freq_termsets = apriori(query, inv_index, min_freq=mf)
            
            print(f"Query {i}/{len(queries)}: len = {len(query)}, frequent = {len(freq_termsets)}")

            # vectorized query generated by apriori
            idf_vec = self.query2vec(freq_termsets) # (1 X len(termsets)) vector
            
            # vectorized documents generated by apriori query
            tsf_ij = self.termsets2vec(freq_termsets) # (len(termsets) X N) matrix
            
            # append matrix representation of termset frequency per document
            self._docs2vec.append(tsf_ij)

            # append vector query generated by apriori
            self._q2vec.append(idf_vec)

            # print(f'{(time() - start):.2f} secs.\n') TODO: loadbar
        return self


    def evaluate(self, relevant):
        
        num_of_q = len(self._q2vec)

        # for each query and (dtm, relevant) pair
        for i, (qv, dv, rel) in enumerate(zip(self._q2vec, self._docs2vec, relevant)):
            
            # all the money function
            # document - termset matrix
            dtsm = self.tsf_idf(dv, qv)

            # cosine similarity between query and every document
            qd_sims = self.qd_similarities(qv, dtsm)

            # rank them in desc order
            retrieved_docs = self.rank_documents(qd_sims)

            # precision | recall of ranking
            pre, rec = precision_recall(retrieved_docs.keys(), rel)

            print(f"=> Query {i+1}/{num_of_q}, precision = {pre:.3f}, recall = {rec:.3f}")

            self.precision.append(round(pre, 3))
            self.recall.append(round(rec, 3))

        return array(self.precision), array(self.recall)
    

    def tsf_idf(self, tf_ij, idf):
        ########## each column corresponds to a document #########
        return tf_ij * idf.reshape(-1, 1)